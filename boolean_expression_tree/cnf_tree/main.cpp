#include "tree.h"
#include "key_schedule.h"
#include "working_code.h"
#include <vector>
#include <iostream>
#include <iomanip>

int carnival_code_length = 0x72;
uint8 carnival_code[0x72] = { 0xF4, 0xD7, 0xD1, 0x9E, 0x46, 0x4F, 0x90, 0xF0, 0xA1, 0x3C,
								0x59, 0xA3, 0xFA, 0x09, 0x3C, 0x2A, 0x0B, 0x5A, 0x44, 0x1B,
								0x7E, 0x23, 0x72, 0x63, 0xDD, 0xFA, 0x41, 0x27, 0x9A, 0x46,
								0x8B, 0xAE, 0xA7, 0xFB, 0xE2, 0xF5, 0x04, 0x01, 0x9A, 0x51,
								0xC3, 0x7A, 0x35, 0x58, 0x81, 0xAC, 0x59, 0xC2, 0xC3, 0x2A,
								0xE4, 0x26, 0xAB, 0x90, 0x1F, 0x52, 0x84, 0xD4, 0xF5, 0x49,
								0xC5, 0xE1, 0x55, 0xDC, 0xD8, 0x41, 0x28, 0xD1, 0x43, 0xF6,
								0xF7, 0xA6, 0x6E, 0x52, 0xD2, 0xE4, 0x34, 0x39, 0xA1, 0x15,
								0x1A, 0x31, 0x13, 0x0F, 0x21, 0xEA, 0xBF, 0x27, 0xF3, 0x23,
								0xA4, 0xA0, 0x30, 0x67, 0x43, 0x32, 0x9B, 0x5C, 0xD2, 0xAB,
								0x9F, 0x1B, 0x46, 0xD2, 0x7C, 0x3F, 0x6E, 0xD7, 0x23, 0xC8,
								0xA6, 0xA1, 0x5E, 0x3D };

uint8 carnival_code_decrypted_machine_code[0x80] = { 0xA2, 0x05, 0xEC, 0x51, 0x04, 0xF0, 0x03, 0x20, 0x88, 0xED,
														0xA9, 0x00, 0x85, 0x3F, 0xA5, 0xFC, 0xC9, 0x02, 0xD0, 0x14,
														0xA0, 0x0F, 0x20, 0x7F, 0xAF, 0xB0, 0x0D, 0xA5, 0xD4, 0xD0,
														0x09, 0xAD, 0x68, 0x05, 0x18, 0x69, 0x10, 0x8D, 0x68, 0x05,
														0x4C, 0x35, 0xB5, 0xA0, 0x00, 0x20, 0xB6, 0x88, 0x4C, 0x35,
														0xB5, 0xA0, 0x01, 0x20, 0xB6, 0x88, 0x8A, 0xF0, 0x20, 0xA0,
														0x02, 0xDD, 0xA0, 0x03, 0x20, 0xB6, 0x88, 0xAD, 0x58, 0x05,
														0xC9, 0xF0, 0x90, 0x11, 0xA2, 0x12, 0xBD, 0x8B, 0xB9, 0x9D,
														0x57, 0x01, 0xCA, 0x10, 0xF7, 0x20, 0x52, 0x89, 0x4C, 0xEE,
														0x81, 0xA5, 0x48, 0x29, 0x07, 0xD0, 0x0C, 0xAD, 0x0B, 0x01,
														0xAE, 0x0A, 0x01, 0x8E, 0x0B, 0x01, 0x8D, 0x0A, 0x01, 0x4C,
														0x35, 0xB5, 0xC9, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
														0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

uint8_t carnival_world_working_code[0x80] = { 0xFD, 0x22, 0x3C, 0x40, 0x77, 0xEB, 0xD4, 0xEF, 0x9C, 0x44,
											0x93, 0x1C, 0xD7, 0xF8, 0x10, 0x97, 0x14, 0x93, 0x84, 0x22,
											0xDD, 0xE3, 0x3E, 0x77, 0x5C, 0x47, 0x11, 0x31, 0xAA, 0xD9,
											0xF1, 0x97, 0xE2, 0x44, 0x4E, 0x78, 0x05, 0x25, 0xCD, 0xBF,
											0xAE, 0xED, 0xCA, 0xD6, 0x1F, 0xD9, 0x30, 0x4D, 0x88, 0x18,
											0xB2, 0x89, 0xF6, 0x70, 0x43, 0xFE, 0x56, 0x3E, 0xF3, 0x1B,
											0x7C, 0xA0, 0xF7, 0xF8, 0xDF, 0xF5, 0x3C, 0xC7, 0xE9, 0xD5,
											0x24, 0x0E, 0xDA, 0xA9, 0xB0, 0xAA, 0x86, 0x51, 0x1F, 0x8F,
											0x4A, 0xEF, 0x8C, 0x81, 0xF8, 0x80, 0x4F, 0x8F, 0x54, 0xF2,
											0x8C, 0x14, 0x9C, 0xFA, 0xFE, 0xCF, 0x03, 0x82, 0x96, 0x4E,
											0x82, 0x4C, 0x4A, 0x72, 0x1C, 0x52, 0x2C, 0xDE, 0x0F, 0x94,
											0x58, 0xC2, 0xD6, 0x99, 0x36, 0x7F, 0xA3, 0xF0, 0xD1, 0x29,
											0xD0, 0x93, 0xBF, 0x42, 0xCF, 0x3D, 0xD2, 0x56 };

uint8_t carnival_working_code_final_map_step7_before_alg6[0x80] = { 0x90, 0xe3, 0x26, 0xdc, 0x5b, 0xaa, 0x04, 0x4d, 0xef, 0xe5, 0xf2, 0x8d, 0x9d, 0x98, 0xf2, 0xa4, 0xb8, 0xd4, 0x70, 0x2a, 0x4f, 0x4f, 0x9d, 0x0b, 0x00, 0x19, 0x2e, 0xd8, 0xd6, 0x46, 0x7e, 0xcb, 0xac, 0x26, 0x5c, 0x3b, 0x56, 0xad, 0x6e, 0x36, 0x5c, 0x76, 0xce, 0xc8, 0x23, 0xe6, 0x8f, 0x09, 0xd5, 0xdc, 0xe3, 0x21, 0x66, 0x5d, 0x0b, 0x4c, 0xe6, 0xff, 0xcc, 0xa8, 0x51, 0xd7, 0x65, 0xd0, 0x3d, 0xba, 0x94, 0xf6, 0x2d, 0x22, 0xfb, 0x5d, 0x0a, 0xcd, 0xad, 0xf0, 0xb7, 0x7b, 0x43, 0x01, 0x2d, 0x26, 0xa1, 0xbf, 0xcb, 0x8c, 0xd3, 0x9b, 0xa4, 0xf6, 0x83, 0xc9, 0xbf, 0x01, 0xfc, 0x7e, 0x1a, 0xa1, 0x2f, 0x55, 0xcf, 0xc3, 0x93, 0x93, 0x0f, 0xbc, 0xc1, 0xed, 0x6d, 0x0a, 0xd2, 0xff, 0x2f, 0x8c, 0xaf, 0xed, 0xd4, 0x43, 0x5e, 0x6f, 0xcf, 0xaf, 0xc4, 0xf0, 0xfa, 0x18, 0x63, 0xfb };

uint8_t carnival_working_code_final_map_step8_before_alg3[0x80] = { 0xc8, 0xf1, 0x93, 0x6e, 0xad, 0x55, 0x02, 0x26, 0xf7, 0xf2, 0xf9, 0x46, 0x4e, 0x4c, 0xf9, 0xd2, 0xdc, 0x6a, 0xb8, 0x95, 0xa7, 0x27, 0x4e, 0x05, 0x80, 0x8c, 0x17, 0x6c, 0x6b, 0xa3, 0xbf, 0xe5, 0x56, 0x93, 0xae, 0x9d, 0x2b, 0x56, 0xb7, 0x9b, 0xae, 0x3b, 0xe7, 0xe4, 0x11, 0xf3, 0x47, 0x84, 0xea, 0x6e, 0xf1, 0x10, 0xb3, 0x2e, 0x05, 0xa6, 0x73, 0xff, 0x66, 0xd4, 0xa8, 0x6b, 0xb2, 0x68, 0x1e, 0xdd, 0x4a, 0xfb, 0x16, 0x11, 0xfd, 0x2e, 0x05, 0xe6, 0x56, 0xf8, 0xdb, 0x3d, 0xa1, 0x00, 0x96, 0x93, 0x50, 0xdf, 0xe5, 0x46, 0xe9, 0xcd, 0x52, 0xfb, 0xc1, 0x64, 0xdf, 0x80, 0x7e, 0xbf, 0x8d, 0x50, 0x97, 0xaa, 0x67, 0xe1, 0xc9, 0x49, 0x87, 0xde, 0x60, 0xf6, 0xb6, 0x05, 0xe9, 0xff, 0x17, 0xc6, 0xd7, 0xf6, 0x6a, 0xa1, 0xaf, 0x37, 0x67, 0xd7, 0x62, 0x78, 0xfd, 0x0c, 0x31, 0xfd };

uint8_t carnival_working_code_final_map_step9_before_alg4[0x80] = { 0x4b, 0xa6, 0xdd, 0xf0, 0xe9, 0xe8, 0x69, 0x45, 0x51, 0xb8, 0x7d, 0xcf, 0x65, 0xeb, 0x2d, 0xdd, 0x04, 0x54, 0x7f, 0x61, 0xa2, 0xbc, 0x6c, 0x53, 0x29, 0xd6, 0xbf, 0x1d, 0xfb, 0x5d, 0x83, 0x29, 0x75, 0x60, 0xa3, 0xfe, 0x9b, 0x05, 0x08, 0xe1, 0xcc, 0xf2, 0xce, 0xf0, 0x19, 0x6b, 0x81, 0x23, 0xa4, 0x04, 0x0c, 0x26, 0xa7, 0x3b, 0x9f, 0x1d, 0xca, 0x8e, 0x22, 0x0a, 0x43, 0x86, 0xcb, 0x2b, 0x6e, 0x13, 0x74, 0xfe, 0x4b, 0xba, 0x79, 0x88, 0x2f, 0xe3, 0x7f, 0x53, 0x5b, 0xeb, 0xef, 0x1d, 0xcb, 0x50, 0x34, 0x11, 0x4f, 0xbb, 0x90, 0xde, 0x02, 0xe7, 0x3e, 0xc8, 0x7d, 0xd2, 0x6f, 0xe6, 0xb2, 0x18, 0x67, 0x2d, 0xf8, 0x4c, 0xa4, 0x79, 0xd3, 0xe0, 0x1b, 0xf7, 0x42, 0x89, 0x52, 0xaf, 0xdd, 0xb9, 0xc5, 0xf4, 0x2b, 0x8f, 0xe7, 0xc2, 0x80, 0x63, 0x48, 0xc2, 0x18, 0x58, 0x78, 0x26 };

uint8_t carnival_working_code_final_map_step10_before_alg7[0x80] = { 0x6c, 0xb1, 0xbf, 0x56, 0xb0, 0x97, 0x29, 0xc9, 0x62, 0x88, 0x4f, 0x90, 0x81, 0x12, 0xe3, 0x84, 0x83, 0x74, 0x52, 0x32, 0xa2, 0x2d, 0xac, 0xb1, 0xbb, 0x6d, 0xf6, 0x57, 0x0b, 0x10, 0xd3, 0xa9, 0x96, 0x34, 0x8d, 0xdb, 0xf7, 0x54, 0x5d, 0xc2, 0x96, 0xcc, 0x30, 0x40, 0x74, 0x4b, 0x79, 0xf4, 0xce, 0x7f, 0x37, 0xdb, 0x8b, 0xf5, 0x6d, 0xa8, 0xe9, 0xf3, 0x54, 0x83, 0x3d, 0x5c, 0xa6, 0x43, 0xe3, 0x4c, 0xc3, 0x30, 0xcf, 0x9e, 0x16, 0x65, 0x42, 0x30, 0xaf, 0xb0, 0x5c, 0x62, 0x8a, 0x19, 0x87, 0x26, 0xe9, 0x0c, 0x6b, 0x33, 0xc5, 0x3a, 0x10, 0x7c, 0xcc, 0xa2, 0xe4, 0xc8, 0x57, 0x25, 0x8c, 0xa9, 0x7e, 0x2f, 0x41, 0x37, 0x0f, 0xdf, 0xa2, 0x2a, 0x1d, 0x99, 0xee, 0xac, 0xd7, 0x6c, 0xa7, 0x2f, 0x71, 0xcb, 0x90, 0x68, 0xc1, 0x34, 0x54, 0x46, 0x95, 0x9f, 0xfa, 0xce, 0x4c, 0xcd };


void main()
{
	uint64 tree_size;
	std::vector<node*> org_bits;
	

	init_primitives(32+1024);
	//init_primitives(64);
	for (int i = 0; i < 64; i++)
	{
		org_bits.push_back(get_node_prim(i));
	}

	/*std::vector<node*>* rng_test = rng_calc_new(org_bits.begin(), org_bits.begin() + 8);

	for (int i = 0; i < 100000 - 1; i++)
	{
		rng_test = rng_calc_new(rng_test->begin(), rng_test->begin() + 8);
	}

	std::vector<node*>* rng_test_result = new std::vector<node*>();
	rng_test_result->insert(rng_test_result->end(), rng_test->begin() + 16, rng_test->end());

	node* rng_test_desired = new_node(AND,
		new_node(AND,
			(*rng_test_result)[0],
			new_node(AND,
				new_node(NOT, (*rng_test_result)[1], NULL),
				new_node(AND,
					(*rng_test_result)[2],
					new_node(AND,
						new_node(NOT, (*rng_test_result)[3], NULL),
						new_node(AND,
							(*rng_test_result)[4],
							new_node(AND,
								new_node(NOT, (*rng_test_result)[5], NULL),
								(*rng_test_result)[6]
							)
						)
					)
				)
			)
		),
		new_node(NOT, (*rng_test_result)[7], NULL)
	);

	rng_test_desired->simplify_tree();
	rng_test_desired->get_tseitin_terms_tree();


	return;*/

	/*
	std::vector<node*>* sum_test = new std::vector<node*>();
	sum_test->insert(sum_test->end(), rng_vals->begin() + 16, rng_vals->end());
	*/

	//node* x = new_node(AND,
	//	(*sum_test)[0],
	//	(*sum_test)[1]
	//);


	/*node* greater_than_test = greater_than_static(&org_bits, 0xD576, 16);

	greater_than_test->simplify_tree();
	tree_size = greater_than_test->get_tseitin_terms_tree();

	return;*/


	int map_list[26] = { 0x00, 0x02, 0x05, 0x04, 0x03, 0x1D, 0x1C, 0x1E, 0x1B, 0x07, 0x08, 0x06, 0x09, 0x0C, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x0E, 0x0F, 0x10, 0x12, 0x11 };

	std::vector < std::vector<node*>*>* key_schedule_list = new std::vector < std::vector<node*>*>();
	std::vector<node*>* key_schedule = new std::vector<node*>();
	key_schedule->insert(key_schedule->end(), org_bits.begin(), org_bits.begin() + 32);

	//uint8 map = 0x12;
	//std::vector<node*>* new_key_schedule = key_schedule_algorithm_7(11, key_schedule->begin());
	//std::vector<node*>* new_key_schedule = run_key_schedule(map, key_schedule->begin());


	for (int i = 0; i < 26; i++)
	{
		key_schedule = run_key_schedule(map_list[i], key_schedule->begin());
		key_schedule_list->push_back(key_schedule);

		if (map_list[i] == 0x22)
		{
			key_schedule = key_schedule_algorithm(map_list[i], key_schedule->begin(), 4);
			key_schedule_list->push_back(key_schedule);
		}
	}





	std::vector<node*>* bitfield_single_map = new std::vector<node*>();
	for (int i = 0; i < 1024; i++)
	{
		bitfield_single_map->push_back(get_node_prim(i + 32));
	}
	std::vector<node*>* final_key_sched = new std::vector<node*>();
	for (int i = 0; i < 32; i++)
	{
		final_key_sched->push_back(get_node_prim(i));
	}

	working_code in_progress_single_map(bitfield_single_map, NULL);

	in_progress_single_map.process_working(final_key_sched, 15);

	node* single_bit = (*in_progress_single_map.bitfield)[1023];
	single_bit->simplify_tree();
	tree_size = single_bit->get_tseitin_terms_tree();
	return;

	std::vector<node*>* decrypted_single_map = decrypt_memory(in_progress_single_map.bitfield, carnival_code, carnival_code_length);
	node* carnival_single_map = new_node_bit(1);
	for (int i = 0; i < carnival_code_length; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (carnival_code_decrypted_machine_code[i] >> bit_index) & 0x01;
			node* next_node = (*decrypted_single_map)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = new_node(NOT, next_node, NULL);
			}
			carnival_single_map = new_node(AND, carnival_single_map, next_node);
		}
	}
	carnival_single_map = new_node(AND, carnival_single_map, in_progress_single_map.alg06_node);

	//uint8 result_vals[8+128] = {
	//	0x00,0xc8,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe7,0xfb,0xed,0x49,0x5b,0x5b,0xc8,0xfc,0x7e,0xe5,0xcb,0x80,0xe2,0x6a,0xbb,0xc4,0x36,0x2d,0x84,0xe7,0xa8,0x07,0x00,0xe3,0x46,0x46,0xc4,0x06,0x95,0xc8,0x81,0xe0,0x00,0x80,0x4f,0xd9,0x89,0xc5,0x80,0xd1,0xe0,0xf4,0xa7,0xae,0x01,0xec,0x00,0x79,0x06,0x94,0x6a,0x84,0x67,0xf1,0x6b,0xa8,0xb1,0xe8,0xe7,0xc0,0x28,0x2a,0x60,0x09,0x0a,0x10,0x90,0xd3,0x01,0x40,0xa7,0x5c,0x91,0x8e,0x96,0x60,0x87,0xb8,0x81,0x80,0x8c,0x58,0xc4,0xe1,0x81,0x4a,0x89,0xe4,0xcb,0x6d,0xe0,0x34,0x00,0x80,0x80,0x84,0x09,0x30,0x41,0x28,0x3b,0x40,0x38,0x40,0x59,0x38,0x88,0x00,0xa4,0x43,0x42,0x2a,0x30,0x33
	//};
	//set_prims(32+1024, result_vals);

	carnival_single_map->simplify_tree();
	tree_size = carnival_single_map->get_tseitin_terms_tree();
	return;



	uint8 value[8];

	// For the known working code, the payload is the following:
	value[0] = 0x2c;
	value[1] = 0xa5;
	value[2] = 0xb4;
	value[3] = 0x2d;
	value[4] = 0xf7;
	value[5] = 0x3a;
	value[6] = 0x26;
	value[7] = 0x12;
	// That key gives this final key sched vals:
	value[0] = 0xCA;
	value[1] = 0x86;
	value[2] = 0x17;
	value[3] = 0xA2;


	//// Possible key which generates a final key sched value 
	//value[0] = 0x3F;
	//value[1] = 0x2D;
	//value[2] = 0xA6;
	//value[3] = 0xBE;
	



	/*node* desired_key_sched = get_desired_node(key_schedule_list->back(), value);

	desired_key_sched->simplify_tree();
	tree_size = desired_key_sched->get_tseitin_terms_tree();
	return;*/




	std::vector<node*>* bitfield = new std::vector<node*>();
	bitfield->insert(bitfield->end(), org_bits.begin(), org_bits.end());

	std::vector<node*>* rng_vals = new std::vector<node*>();
	rng_vals->insert(rng_vals->end(), org_bits.begin(), org_bits.begin() + 16);

	for (int i = 8; i < 128; i++)
	{
		rng_vals = rng_calc(rng_vals->begin(), rng_vals->begin() + 8);

		std::vector<node*>* next_sum = add_bits(bitfield->begin() + ((i - 8) * 8), rng_vals->begin() + 16, new_node_bit(0), 8);
		bitfield->insert(bitfield->end(), next_sum->begin(), next_sum->begin() + 8);
	}

	working_code in_progress(bitfield, NULL);

	int counter = 0;
	for (auto it = key_schedule_list->begin(); it != key_schedule_list->end(); it++)
	{
		in_progress.process_working((*it));
		
		/*counter++;
		if (counter > 0)
		{
			break;
		}*/
	}

	std::vector<node*>* decrypted = decrypt_memory(in_progress.bitfield, carnival_code, carnival_code_length);


	node* carnival_desired_decrypted = new_node_bit(1);
	for (int i = 0; i < carnival_code_length; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (carnival_code_decrypted_machine_code[i] >> bit_index) & 0x01;
			node* next_node = (*decrypted)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = new_node(NOT, next_node, NULL);
			}
			carnival_desired_decrypted = new_node(AND, carnival_desired_decrypted, next_node);
		}
	}

	set_prims(32, value);

	carnival_desired_decrypted->simplify_tree();
	tree_size = carnival_desired_decrypted->get_tseitin_terms_tree();
	return;


	node* checksum = checksum_bitfield(decrypted);
	//set_prims(64, value);
	checksum->simplify_tree();

	tree_size = checksum->get_tseitin_terms_tree();

	return;


	set_prims(64, value);


	//std::vector<uint8>* working_code_bytes = bitfield_to_bytes(decrypted);
	//for (auto it = working_code_bytes->begin(); it != working_code_bytes->end(); it++)
	//{
	//	std::cout << std::setfill('0') << std::setw(2) << std::hex << (int)(*it);
	//}

	
	
	return;


	node* blah = (*in_progress.bitfield)[0];
	std::vector<uint64>* node_counts;



	/*node_counts = blah->get_node_type_counts_tree();
	for (int i = 0; i < 8; i++)
	{
		std::cout << i << " " << (*node_counts)[i] << "\n";
	}

	std::cout << blah->count_refs_tree() << "\n";*/

	blah->simplify_tree();
	
	/*node_counts = blah->get_node_type_counts_tree();
	for (int i = 0; i < 8; i++)
	{
		std::cout << i << " " << (*node_counts)[i] << "\n";
	}

	std::cout << blah->count_refs_tree() << "\n";

	return;*/

	tree_size = blah->get_tseitin_terms_tree();

	//// std::cout << tree_size;
	//std::cout << (blah->node_id + 1) << " 0\n";

	//std::cout << tree_size;
	return;
	

	//std::vector<node*>* fake_rng = new std::vector<node*>();
	//std::vector<node*>* zero = get_static_byte(0);
	//fake_rng->insert(fake_rng->end(), zero->begin(), zero->end());
	//fake_rng->insert(fake_rng->end(), zero->begin(), zero->end());

	//std::vector<node*>* new_working_code = alg7(working_code, fake_rng);

	//std::cout << working_code->size();

	uint32 set_val = 0b00101101101101001010010100101100;

	for (int i = 0; i < 32; i++)
	{
		node* t = get_node_prim(i);
		t->type = VAL;
		t->val = (set_val >> i) & 0x01;
		t->node_id = 0;
	}

	set_val = 0b00010010001001100011101000100111;

	for (int i = 0; i < 32; i++)
	{
		node* t = get_node_prim(i+32);
		t->type = VAL;
		t->val = (set_val >> i) & 0x01;
		t->node_id = 0;
	}


	print_vals(in_progress.bitfield);
	//std::cout << "\n";
	//print_vals(working_code);

	return;




	std::vector<node*>* new_key_schedule = key_schedule;

	set_val = 0b01101001111010100011010111100001;

	for (int i = 0; i < 32; i++)
	{
		node* t = get_node_prim(i);
		t->type = VAL;
		t->val = (set_val >> i) & 0x01;
		t->node_id = 0;
	}

	uint32 outval = 0;

	for (int i = (*new_key_schedule).size() - 1; i >= 0; i--)
	{
		node* x = (*new_key_schedule)[i];
		x->simplify_tree();
		if (x->type != VAL)
		{
			std::cout << i << " ???\n";
		}
		else
		{
			std::cout << ((int)x->val) << "";
			outval = outval | (x->val << i);
		}
	}

	std::cout << "\n";

	std::cout << (outval & 0xFF) << " " << ((outval >> 8) & 0xFF) << " " << ((outval >> 16) & 0xFF) << " " << ((outval >> 24) & 0xFF) << "\n";

	return;

	uint32 desired_val = 0b00101001101000011011110110000100;

	node* prev_node = new_node_bit(1);
	for (int i = 0; i < 32; i++)
	{
		uint8 val = (desired_val >> i) & 0x01;
		if (val == 1)
		{
			prev_node = new_node(AND, prev_node, (*new_key_schedule)[i]);
		}
		else
		{
			prev_node = new_node(AND, prev_node, new_node(NOT, (*new_key_schedule)[i], NULL));
		}
	}

	prev_node->simplify_tree();

	tree_size = prev_node->get_tseitin_terms_tree();

	std::cout << (prev_node->node_id + 1) << " 0\n";

	std::cout << tree_size;



	return;


	//node* and_test = new_node(AND, get_node_prim(0), get_node_prim(1));

	//and_test->simplify();

	//and_test->clear_node_ids();
	//uint64 and_test_tree_size = and_test->get_tseitin_terms(64);

	//std::cout << and_test_tree_size;
	//return;



	/*node* or_test = new_node(OR, get_node_prim(0), get_node_prim(1));

	or_test->simplify();

	or_test->clear_node_ids();
	uint64 or_test_tree_size = or_test->get_tseitin_terms(64);

	std::cout << or_test_tree_size;
	return;*/



	//node* xor_test = new_node(XOR, get_node_prim(0), get_node_prim(1));

	//xor_test->simplify();

	//xor_test->clear_node_ids();
	//uint64 xor_test_tree_size = xor_test->get_tseitin_terms(64);

	//std::cout << xor_test_tree_size;
	//return;



	//node* not_test = new_node(NOT, get_node_prim(0), get_node_prim(1));

	//not_test->simplify();

	//not_test->clear_node_ids();
	//uint64 not_test_tree_size = not_test->get_tseitin_terms(64);

	//std::cout << not_test_tree_size;
	//return;



	//org_bits[0]->print_tree();

	//std::vector<node*>* sum_test = add_bytes(org_bits.begin(), org_bits.begin() + 8, *(org_bits.begin() + 9));

	//std::vector<node*>* sum_test = add_byte_static(org_bits.begin(), 0x12, new_node_bit(0));


    //std::vector<node*>* 
		rng_vals = rng_calc(org_bits.begin(), org_bits.begin() + 8);

	for (int i = 0; i < 100-1; i++)
	{
		rng_vals = rng_calc(rng_vals->begin(), rng_vals->begin() + 8);
	}

	std::vector<node*>* sum_test = new std::vector<node*>();
	sum_test->insert(sum_test->end(), rng_vals->begin() + 16, rng_vals->end());

	//node* x = new_node(AND,
	//	(*sum_test)[0],
	//	(*sum_test)[1]
	//);


	//uint32 set_val = 0b0100010101110010;

	for (int i = 0; i < 16; i++)
	{
		node* t = get_node_prim(i);
		t->type = VAL;
		t->val = (set_val >> i) & 0x01;
		t->node_id = 0;
	}

	for (int i = 7; i >=0; i--)
	{
		node* x = (*sum_test)[i];
		x->simplify_tree();
		if (x->type != VAL)
		{
			std::cout << i << " ???\n";
		}
		else
		{
			std::cout << ((int)x->val) << "";
		}
	}

	std::cout << "\n";

	return;




	node* x = new_node(AND,
		new_node(AND,
			(*sum_test)[0],
			new_node(AND,
				new_node(NOT, (*sum_test)[1], NULL),
				new_node(AND,
					(*sum_test)[2],
					new_node(AND,
						new_node(NOT, (*sum_test)[3], NULL),
						new_node(AND,
							(*sum_test)[4],
							new_node(AND,
								new_node(NOT, (*sum_test)[5], NULL),
								(*sum_test)[6]
							)
						)
					)
				)
			)
		),
		new_node(NOT, (*sum_test)[7], NULL)
	);

	


	//(*sum_test)[1]->get_string();
	//(*sum_test)[7]->print_tree();
	//std::cout << "simplify\n";
	//(*sum_test)[8]->simplify();
	//(*sum_test)[8]->print_tree();
	//for (int i = 0; i < 64; i++)
	//{
	//	org_bits[i]->get_string();
	//}

	//x->simplify();
	//x->print_tree(0);


	//x->clear_node_ids();

	/*
	x->set_node_ids(INT_MAX);
	x->set_node_ids(0);
	*/

	x->simplify_tree();
	//x->print_tree(0);


	//x->clear_node_ids();
	/*
	x->set_node_ids(INT_MAX);
	x->set_node_ids(0);
	*/
	tree_size = x->get_tseitin_terms_tree();

	// std::cout << tree_size;
	std::cout << (x->node_id + 1) << " 0\n";
	
	std::cout << tree_size;
	/*
	handle as bytes vs bits
	add two bytes
		optional input carry
		want output carry or not
	*/

	return;
}