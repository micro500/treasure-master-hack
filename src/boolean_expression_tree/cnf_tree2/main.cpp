#include "working_code.h"
#include "tree_manager.h"
#include "key_schedule.h"
#include <vector>
#include <iostream>
#include <iomanip>

int carnival_code_length = 0x72;
uint8 carnival_code[0x72] = { 0xF4, 0xD7, 0xD1, 0x9E, 0x46, 0x4F, 0x90, 0xF0, 0xA1, 0x3C,
								0x59, 0xA3, 0xFA, 0x09, 0x3C, 0x2A, 0x0B, 0x5A, 0x44, 0x1B,
								0x7E, 0x23, 0x72, 0x63, 0xDD, 0xFA, 0x41, 0x27, 0x9A, 0x46,
								0x8B, 0xAE, 0xA7, 0xFB, 0xE2, 0xF5, 0x04, 0x01, 0x9A, 0x51,
								0xC3, 0x7A, 0x35, 0x58, 0x81, 0xAC, 0x59, 0xC2, 0xC3, 0x2A,
								0xE4, 0x26, 0xAB, 0x90, 0x1F, 0x52, 0x84, 0xD4, 0xF5, 0x49,
								0xC5, 0xE1, 0x55, 0xDC, 0xD8, 0x41, 0x28, 0xD1, 0x43, 0xF6,
								0xF7, 0xA6, 0x6E, 0x52, 0xD2, 0xE4, 0x34, 0x39, 0xA1, 0x15,
								0x1A, 0x31, 0x13, 0x0F, 0x21, 0xEA, 0xBF, 0x27, 0xF3, 0x23,
								0xA4, 0xA0, 0x30, 0x67, 0x43, 0x32, 0x9B, 0x5C, 0xD2, 0xAB,
								0x9F, 0x1B, 0x46, 0xD2, 0x7C, 0x3F, 0x6E, 0xD7, 0x23, 0xC8,
								0xA6, 0xA1, 0x5E, 0x3D };

uint8 carnival_code_decrypted_machine_code[0x80] = { 0xA2, 0x05, 0xEC, 0x51, 0x04, 0xF0, 0x03, 0x20, 0x88, 0xED,
														0xA9, 0x00, 0x85, 0x3F, 0xA5, 0xFC, 0xC9, 0x02, 0xD0, 0x14,
														0xA0, 0x0F, 0x20, 0x7F, 0xAF, 0xB0, 0x0D, 0xA5, 0xD4, 0xD0,
														0x09, 0xAD, 0x68, 0x05, 0x18, 0x69, 0x10, 0x8D, 0x68, 0x05,
														0x4C, 0x35, 0xB5, 0xA0, 0x00, 0x20, 0xB6, 0x88, 0x4C, 0x35,
														0xB5, 0xA0, 0x01, 0x20, 0xB6, 0x88, 0x8A, 0xF0, 0x20, 0xA0,
														0x02, 0xDD, 0xA0, 0x03, 0x20, 0xB6, 0x88, 0xAD, 0x58, 0x05,
														0xC9, 0xF0, 0x90, 0x11, 0xA2, 0x12, 0xBD, 0x8B, 0xB9, 0x9D,
														0x57, 0x01, 0xCA, 0x10, 0xF7, 0x20, 0x52, 0x89, 0x4C, 0xEE,
														0x81, 0xA5, 0x48, 0x29, 0x07, 0xD0, 0x0C, 0xAD, 0x0B, 0x01,
														0xAE, 0x0A, 0x01, 0x8E, 0x0B, 0x01, 0x8D, 0x0A, 0x01, 0x4C,
														0x35, 0xB5, 0xC9, 0x2D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
														0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

uint8_t carnival_world_working_code[0x80] = { 0xFD, 0x22, 0x3C, 0x40, 0x77, 0xEB, 0xD4, 0xEF, 0x9C, 0x44,
											0x93, 0x1C, 0xD7, 0xF8, 0x10, 0x97, 0x14, 0x93, 0x84, 0x22,
											0xDD, 0xE3, 0x3E, 0x77, 0x5C, 0x47, 0x11, 0x31, 0xAA, 0xD9,
											0xF1, 0x97, 0xE2, 0x44, 0x4E, 0x78, 0x05, 0x25, 0xCD, 0xBF,
											0xAE, 0xED, 0xCA, 0xD6, 0x1F, 0xD9, 0x30, 0x4D, 0x88, 0x18,
											0xB2, 0x89, 0xF6, 0x70, 0x43, 0xFE, 0x56, 0x3E, 0xF3, 0x1B,
											0x7C, 0xA0, 0xF7, 0xF8, 0xDF, 0xF5, 0x3C, 0xC7, 0xE9, 0xD5,
											0x24, 0x0E, 0xDA, 0xA9, 0xB0, 0xAA, 0x86, 0x51, 0x1F, 0x8F,
											0x4A, 0xEF, 0x8C, 0x81, 0xF8, 0x80, 0x4F, 0x8F, 0x54, 0xF2,
											0x8C, 0x14, 0x9C, 0xFA, 0xFE, 0xCF, 0x03, 0x82, 0x96, 0x4E,
											0x82, 0x4C, 0x4A, 0x72, 0x1C, 0x52, 0x2C, 0xDE, 0x0F, 0x94,
											0x58, 0xC2, 0xD6, 0x99, 0x36, 0x7F, 0xA3, 0xF0, 0xD1, 0x29,
											0xD0, 0x93, 0xBF, 0x42, 0xCF, 0x3D, 0xD2, 0x56 };

uint8_t carnival_working_code_final_map_step7_before_alg6[0x80] = { 0x90, 0xe3, 0x26, 0xdc, 0x5b, 0xaa, 0x04, 0x4d, 0xef, 0xe5, 0xf2, 0x8d, 0x9d, 0x98, 0xf2, 0xa4, 0xb8, 0xd4, 0x70, 0x2a, 0x4f, 0x4f, 0x9d, 0x0b, 0x00, 0x19, 0x2e, 0xd8, 0xd6, 0x46, 0x7e, 0xcb, 0xac, 0x26, 0x5c, 0x3b, 0x56, 0xad, 0x6e, 0x36, 0x5c, 0x76, 0xce, 0xc8, 0x23, 0xe6, 0x8f, 0x09, 0xd5, 0xdc, 0xe3, 0x21, 0x66, 0x5d, 0x0b, 0x4c, 0xe6, 0xff, 0xcc, 0xa8, 0x51, 0xd7, 0x65, 0xd0, 0x3d, 0xba, 0x94, 0xf6, 0x2d, 0x22, 0xfb, 0x5d, 0x0a, 0xcd, 0xad, 0xf0, 0xb7, 0x7b, 0x43, 0x01, 0x2d, 0x26, 0xa1, 0xbf, 0xcb, 0x8c, 0xd3, 0x9b, 0xa4, 0xf6, 0x83, 0xc9, 0xbf, 0x01, 0xfc, 0x7e, 0x1a, 0xa1, 0x2f, 0x55, 0xcf, 0xc3, 0x93, 0x93, 0x0f, 0xbc, 0xc1, 0xed, 0x6d, 0x0a, 0xd2, 0xff, 0x2f, 0x8c, 0xaf, 0xed, 0xd4, 0x43, 0x5e, 0x6f, 0xcf, 0xaf, 0xc4, 0xf0, 0xfa, 0x18, 0x63, 0xfb };

uint8_t carnival_working_code_final_map_step8_before_alg3[0x80] = { 0xc8, 0xf1, 0x93, 0x6e, 0xad, 0x55, 0x02, 0x26, 0xf7, 0xf2, 0xf9, 0x46, 0x4e, 0x4c, 0xf9, 0xd2, 0xdc, 0x6a, 0xb8, 0x95, 0xa7, 0x27, 0x4e, 0x05, 0x80, 0x8c, 0x17, 0x6c, 0x6b, 0xa3, 0xbf, 0xe5, 0x56, 0x93, 0xae, 0x9d, 0x2b, 0x56, 0xb7, 0x9b, 0xae, 0x3b, 0xe7, 0xe4, 0x11, 0xf3, 0x47, 0x84, 0xea, 0x6e, 0xf1, 0x10, 0xb3, 0x2e, 0x05, 0xa6, 0x73, 0xff, 0x66, 0xd4, 0xa8, 0x6b, 0xb2, 0x68, 0x1e, 0xdd, 0x4a, 0xfb, 0x16, 0x11, 0xfd, 0x2e, 0x05, 0xe6, 0x56, 0xf8, 0xdb, 0x3d, 0xa1, 0x00, 0x96, 0x93, 0x50, 0xdf, 0xe5, 0x46, 0xe9, 0xcd, 0x52, 0xfb, 0xc1, 0x64, 0xdf, 0x80, 0x7e, 0xbf, 0x8d, 0x50, 0x97, 0xaa, 0x67, 0xe1, 0xc9, 0x49, 0x87, 0xde, 0x60, 0xf6, 0xb6, 0x05, 0xe9, 0xff, 0x17, 0xc6, 0xd7, 0xf6, 0x6a, 0xa1, 0xaf, 0x37, 0x67, 0xd7, 0x62, 0x78, 0xfd, 0x0c, 0x31, 0xfd };

uint8_t carnival_working_code_final_map_step9_before_alg4[0x80] = { 0x4b, 0xa6, 0xdd, 0xf0, 0xe9, 0xe8, 0x69, 0x45, 0x51, 0xb8, 0x7d, 0xcf, 0x65, 0xeb, 0x2d, 0xdd, 0x04, 0x54, 0x7f, 0x61, 0xa2, 0xbc, 0x6c, 0x53, 0x29, 0xd6, 0xbf, 0x1d, 0xfb, 0x5d, 0x83, 0x29, 0x75, 0x60, 0xa3, 0xfe, 0x9b, 0x05, 0x08, 0xe1, 0xcc, 0xf2, 0xce, 0xf0, 0x19, 0x6b, 0x81, 0x23, 0xa4, 0x04, 0x0c, 0x26, 0xa7, 0x3b, 0x9f, 0x1d, 0xca, 0x8e, 0x22, 0x0a, 0x43, 0x86, 0xcb, 0x2b, 0x6e, 0x13, 0x74, 0xfe, 0x4b, 0xba, 0x79, 0x88, 0x2f, 0xe3, 0x7f, 0x53, 0x5b, 0xeb, 0xef, 0x1d, 0xcb, 0x50, 0x34, 0x11, 0x4f, 0xbb, 0x90, 0xde, 0x02, 0xe7, 0x3e, 0xc8, 0x7d, 0xd2, 0x6f, 0xe6, 0xb2, 0x18, 0x67, 0x2d, 0xf8, 0x4c, 0xa4, 0x79, 0xd3, 0xe0, 0x1b, 0xf7, 0x42, 0x89, 0x52, 0xaf, 0xdd, 0xb9, 0xc5, 0xf4, 0x2b, 0x8f, 0xe7, 0xc2, 0x80, 0x63, 0x48, 0xc2, 0x18, 0x58, 0x78, 0x26 };

uint8_t carnival_working_code_final_map_step10_before_alg7[0x80] = { 0x6c, 0xb1, 0xbf, 0x56, 0xb0, 0x97, 0x29, 0xc9, 0x62, 0x88, 0x4f, 0x90, 0x81, 0x12, 0xe3, 0x84, 0x83, 0x74, 0x52, 0x32, 0xa2, 0x2d, 0xac, 0xb1, 0xbb, 0x6d, 0xf6, 0x57, 0x0b, 0x10, 0xd3, 0xa9, 0x96, 0x34, 0x8d, 0xdb, 0xf7, 0x54, 0x5d, 0xc2, 0x96, 0xcc, 0x30, 0x40, 0x74, 0x4b, 0x79, 0xf4, 0xce, 0x7f, 0x37, 0xdb, 0x8b, 0xf5, 0x6d, 0xa8, 0xe9, 0xf3, 0x54, 0x83, 0x3d, 0x5c, 0xa6, 0x43, 0xe3, 0x4c, 0xc3, 0x30, 0xcf, 0x9e, 0x16, 0x65, 0x42, 0x30, 0xaf, 0xb0, 0x5c, 0x62, 0x8a, 0x19, 0x87, 0x26, 0xe9, 0x0c, 0x6b, 0x33, 0xc5, 0x3a, 0x10, 0x7c, 0xcc, 0xa2, 0xe4, 0xc8, 0x57, 0x25, 0x8c, 0xa9, 0x7e, 0x2f, 0x41, 0x37, 0x0f, 0xdf, 0xa2, 0x2a, 0x1d, 0x99, 0xee, 0xac, 0xd7, 0x6c, 0xa7, 0x2f, 0x71, 0xcb, 0x90, 0x68, 0xc1, 0x34, 0x54, 0x46, 0x95, 0x9f, 0xfa, 0xce, 0x4c, 0xcd };

void final_key_sched_test()
{
	tree_manager tm;

	/*std::vector<tree_node*>* bitfield_rev_test = new std::vector<tree_node*>();
	for (int i = 0; i < 1024; i++)
	{
		bitfield_rev_test->push_back(tm.get_prim_node(1 + i + 32));
	}*/
	std::vector<tree_node*>* key_sched_test = new std::vector<tree_node*>();
	for (int i = 0; i < 32; i++)
	{
		key_sched_test->push_back(tm.get_prim_node(1 + i));
	}


	int map_list[26] = { 0x00, 0x02, 0x05, 0x04, 0x03, 0x1D, 0x1C, 0x1E, 0x1B, 0x07, 0x08, 0x06, 0x09, 0x0C, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x0E, 0x0F, 0x10, 0x12, 0x11 };

	std::vector < std::vector<tree_node*>*>* key_schedule_list = new std::vector < std::vector<tree_node*>*>();
	std::vector<tree_node*>* key_schedule = new std::vector<tree_node*>();
	key_schedule->insert(key_schedule->end(), key_sched_test->begin(), key_sched_test->begin() + 32);

	for (int i = 0; i < 26; i++)
	{
		key_schedule = run_key_schedule(map_list[i], key_schedule->begin());
		key_schedule_list->push_back(key_schedule);

		if (map_list[i] == 0x22)
		{
			key_schedule = key_schedule_algorithm(map_list[i], key_schedule->begin(), 4);
			key_schedule_list->push_back(key_schedule);
		}
	}



	uint8 final_key_sched_desired_rng[2] = { 0xCA, 0x86 };

	tree_node* key_sched_test_node = tm.new_node_bit(1);

	for (int i = 0; i < 2; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (final_key_sched_desired_rng[i] >> bit_index) & 0x01;
			tree_node* next_node = (*key_schedule)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = tm.new_node(_NOT, next_node);
			}
			key_sched_test_node = tm.new_node(_AND, key_sched_test_node, next_node);
		}
	}

	key_sched_test_node->simplify_tree();
	key_sched_test_node->get_cnf();
}

void full_map_rev()
{
	tree_manager tm;

	std::vector<tree_node*>* bitfield_rev_test = new std::vector<tree_node*>();
	for (int i = 0; i < 1024; i++)
	{
		bitfield_rev_test->push_back(tm.get_prim_node(1 + i + 32));
	}
	std::vector<tree_node*>* key_sched_rev_test = new std::vector<tree_node*>();
	for (int i = 0; i < 32; i++)
	{
		key_sched_rev_test->push_back(tm.get_prim_node(1 + i));
	}

	working_code in_progress_rev_test(bitfield_rev_test, &tm);

	in_progress_rev_test.process_working(key_sched_rev_test, 0, 7);

	uint8 rng_vals_rev_test[2] = { 0x6F, 0x0F };

	tree_node* rng_known_node = tm.new_node_bit(1);
	for (int i = 0; i < 2; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (rng_vals_rev_test[i] >> bit_index) & 0x01;
			tree_node* next_node = (*in_progress_rev_test.rng_vals_init)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = tm.new_node(_NOT, next_node);
			}
			rng_known_node = tm.new_node(_AND, rng_known_node, next_node);
		}
	}

	std::vector<int> rev_path = { 2, 3, 7, 2, 3, 7, 4, 3, 6 };

	in_progress_rev_test.forced_alg_node = tm.new_node_bit(1);

	for (int i = rev_path.size() - 1; i >= 0; i--)
	{
		in_progress_rev_test.process_forced_step(key_sched_rev_test, rev_path[i], 15 - i);
	}

	std::vector<tree_node*>* decrypted_rev = decrypt_memory2(in_progress_rev_test.bitfield, carnival_code, carnival_code_length);
	tree_node* carnival_rev_test = tm.new_node_bit(1);

	for (int i = 0; i < carnival_code_length; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (carnival_code_decrypted_machine_code[i] >> bit_index) & 0x01;
			tree_node* next_node = (*decrypted_rev)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = tm.new_node(_NOT, next_node);
			}
			carnival_rev_test = tm.new_node(_AND, carnival_rev_test, next_node);
		}
	}
	carnival_rev_test = tm.new_node(_AND, carnival_rev_test, in_progress_rev_test.forced_alg_node);
	

	tree_node* final_desired = tm.new_node(_AND, rng_known_node, carnival_rev_test);

	final_desired->simplify_tree();
	final_desired->get_cnf();


	uint8 rev_map_start_rng[2] = { 0xCA, 0x86 };
	tm.set_prims_cnf(16, 1, rev_map_start_rng);

}

void main()
{
	final_key_sched_test();
	return;


	full_map_rev();
	return;

	/*
	init_primitives(32 + 1024);

	std::vector<node*>* bitfield_rev_old = new std::vector<node*>();
	for (int i = 0; i < 1024; i++)
	{
		bitfield_rev_old->push_back(get_node_prim(i + 32));
	}
	std::vector<node*>* key_sched_rev_old = new std::vector<node*>();
	for (int i = 0; i < 32; i++)
	{
		key_sched_rev_old->push_back(get_node_prim(i));
	}

	working_code in_progress_rev_old(bitfield_rev_old, NULL);

	//in_progress_rev_old.process_working(key_sched_rev_old, 15);




	std::vector<node*>* rng_init_rev_old = new std::vector<node*>();
	rng_init_rev_old->insert(rng_init_rev_old->end(), key_sched_rev_old->begin(), key_sched_rev_old->begin() + 16);

	in_progress_rev_old.set_rng_init(rng_init_rev_old);

	in_progress_rev_old.rng_process();

	std::vector<node*>* alg_result = in_progress_rev_old.alg(6);

	std::vector<node*>* new_working_code = new std::vector<node*>();
	new_working_code->insert(new_working_code->end(), alg_result->begin(), alg_result->begin() + 1024);

	std::vector<node*>* new_rng_val = new std::vector<node*>();
	new_rng_val->insert(new_rng_val->end(), alg_result->begin() + 1024, alg_result->begin() + 1024 + 16);

	in_progress_rev_old.bitfield = new_working_code;
	in_progress_rev_old.set_rng_init(new_rng_val);


	node* carnival_rev_old = new_node_bit(1);
	for (int i = 0; i < 1; i++)
	{
		for (int bit_index = 7; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (carnival_working_code_final_map_step8_before_alg3[i] >> bit_index) & 0x01;
			node* next_node = (*in_progress_rev_old.bitfield)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = new_node(NOT, next_node, NULL);
			}
			carnival_rev_old = new_node(AND, carnival_rev_old, next_node);
		}
	}
	//carnival_single_map = new_node(AND, carnival_single_map, in_progress_single_map.alg06_node);

	carnival_rev_old->simplify_tree();
	uint64 tree_size_rev_old = carnival_rev_old->get_tseitin_terms_tree();




	return;
	*/

	tree_manager tm;

	std::vector<tree_node*>* bitfield_rev_test = new std::vector<tree_node*>();
	for (int i = 0; i < 1024; i++)
	{
		bitfield_rev_test->push_back(tm.get_prim_node(1 + i + 32));
	}
	std::vector<tree_node*>* key_sched_rev_test = new std::vector<tree_node*>();
	for (int i = 0; i < 32; i++)
	{
		key_sched_rev_test->push_back(tm.get_prim_node(1 + i));
	}

	working_code in_progress_rev_test(bitfield_rev_test, &tm);

	std::vector<tree_node*>* rng_init_rev_test = new std::vector<tree_node*>();
	rng_init_rev_test->insert(rng_init_rev_test->end(), key_sched_rev_test->begin(), key_sched_rev_test->begin() + 16);

	in_progress_rev_test.rng_vals_init = rng_init_rev_test;

	in_progress_rev_test.forced_alg_node = tm.new_node_bit(1);


	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 6, 7);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 3, 8);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 4, 9);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 7, 10);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 3, 11);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 2, 12);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 7, 13);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 3, 14);
	//in_progress_rev_test.process_forced_step(key_sched_rev_test, 2, 15);

	std::vector<int> rev_path = { 2, 7, 3, 7, 7, 2, 3, 7, 4, 3, 6 };

	for (int i = rev_path.size() - 1; i >= 0; i--)
	{
		in_progress_rev_test.process_forced_step(key_sched_rev_test, rev_path[i], 15 - i);

	}



	uint8 rng_init_vals_rev_test[2] = { 0x6F, 0x0F };
	//uint8 rng_init_vals_rev_test[2] = { 137, 28 };
	//uint8 rng_init_vals_rev_test[2] = { 20, 29 };
	tm.set_prims(16, 1, rng_init_vals_rev_test);
	

	/*
	std::vector<tree_node*>* cur_rng = rng_calc3(key_sched_rev_test->begin(), key_sched_rev_test->begin() + 8);

	std::vector<uint8>* rng_val_next_test = bitfield_to_bytes2(cur_rng);
	for (auto it = rng_val_next_test->begin(); it != rng_val_next_test->end(); it++)
	{
		std::cout << std::setfill('0') << std::setw(2) << std::hex << (int)(*it);
	}
	
	return;
	*/

	
	//print_vals2(in_progress_rev_test.bitfield);
	/*
	std::vector<uint8>* working_code_rev_test = bitfield_to_bytes2(in_progress_rev_test.bitfield);
	for (auto it = working_code_rev_test->begin(); it != working_code_rev_test->end(); it++)
	{
		std::cout << std::setfill('0') << std::setw(2) << std::hex << (int)(*it);
	}

	std::cout << std::endl;

	std::vector<uint8>* rng_next_rev_test = bitfield_to_bytes2(in_progress_rev_test.rng_vals_init);
	for (auto it = rng_next_rev_test->begin(); it != rng_next_rev_test->end(); it++)
	{
		std::cout << std::setfill('0') << std::setw(2) << std::hex << (int)(*it);
	}

	return;
	*/

	//tm.set_prims(1024, 33, carnival_working_code_final_map_step7_before_alg6);


	std::vector<tree_node*>* decrypted_rev = decrypt_memory2(in_progress_rev_test.bitfield, carnival_code, carnival_code_length);


	tree_node* carnival_rev_test = tm.new_node_bit(1);
	
	for (int i = 0; i < carnival_code_length; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (carnival_code_decrypted_machine_code[i] >> bit_index) & 0x01;
			tree_node* next_node = (*decrypted_rev)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = tm.new_node(_NOT, next_node);
			}
			carnival_rev_test = tm.new_node(_AND, carnival_rev_test, next_node);
		}
	}
	carnival_rev_test = tm.new_node(_AND, carnival_rev_test, in_progress_rev_test.forced_alg_node);


	//tm.set_prims(1024, 33, carnival_working_code_final_map_step7_before_alg6);


	carnival_rev_test->simplify_tree();
	carnival_rev_test->get_cnf();

	//tm.set_prims_cnf(16, 1, rng_init_vals_rev_test);
	//tm.set_prims_cnf(1024, 33, carnival_working_code_final_map_step7_before_alg6);

	//carnival_rev_test->simplify_tree();


	return;


	std::vector<tree_node*>* bitfield_single_map2 = new std::vector<tree_node*>();
	for (int i = 0; i < 1024; i++)
	{
		bitfield_single_map2->push_back(tm.get_prim_node(1 + i + 32));
	}
	std::vector<tree_node*>* final_key_sched2 = new std::vector<tree_node*>();
	for (int i = 0; i < 32; i++)
	{
		final_key_sched2->push_back(tm.get_prim_node(1 + i));
	}

	working_code in_progress_single_map2(bitfield_single_map2, &tm);

	in_progress_single_map2.process_working(final_key_sched2, 14);

	std::vector<tree_node*>* decrypted_single_map2 = decrypt_memory2(in_progress_single_map2.bitfield, carnival_code, carnival_code_length);
	tree_node* carnival_single_map2 = tm.new_node_bit(1);
	for (int i = 0; i < carnival_code_length; i++)
	{
		for (int bit_index = 0; bit_index < 8; bit_index++)
		{
			uint8 bit_val = (carnival_code_decrypted_machine_code[i] >> bit_index) & 0x01;
			tree_node* next_node = (*decrypted_single_map2)[i * 8 + bit_index];

			if (bit_val == 0x00)
			{
				next_node = tm.new_node(_NOT, next_node);
			}
			carnival_single_map2 = tm.new_node(_AND, carnival_single_map2, next_node);
		}
	}
	carnival_single_map2 = tm.new_node(_AND, carnival_single_map2, in_progress_single_map2.alg06_node);

	//uint8 result_vals[8+128] = {
	//	0x00,0xc8,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe7,0xfb,0xed,0x49,0x5b,0x5b,0xc8,0xfc,0x7e,0xe5,0xcb,0x80,0xe2,0x6a,0xbb,0xc4,0x36,0x2d,0x84,0xe7,0xa8,0x07,0x00,0xe3,0x46,0x46,0xc4,0x06,0x95,0xc8,0x81,0xe0,0x00,0x80,0x4f,0xd9,0x89,0xc5,0x80,0xd1,0xe0,0xf4,0xa7,0xae,0x01,0xec,0x00,0x79,0x06,0x94,0x6a,0x84,0x67,0xf1,0x6b,0xa8,0xb1,0xe8,0xe7,0xc0,0x28,0x2a,0x60,0x09,0x0a,0x10,0x90,0xd3,0x01,0x40,0xa7,0x5c,0x91,0x8e,0x96,0x60,0x87,0xb8,0x81,0x80,0x8c,0x58,0xc4,0xe1,0x81,0x4a,0x89,0xe4,0xcb,0x6d,0xe0,0x34,0x00,0x80,0x80,0x84,0x09,0x30,0x41,0x28,0x3b,0x40,0x38,0x40,0x59,0x38,0x88,0x00,0xa4,0x43,0x42,0x2a,0x30,0x33
	//};
	//set_prims(32+1024, result_vals);

	carnival_single_map2->simplify_tree();
	carnival_single_map2->get_cnf();
	return;




	std::vector<tree_node*> init_bits;
	for (int i = 0; i < 16; i++)
	{
		init_bits.push_back(tm.get_prim_node(i + 1));
	}

	tree_node* test_rng_1_0 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_0->rng_depth = 6;
	test_rng_1_0->rng_bit_index = 0;

	tree_node* test_rng_1_1 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_1->rng_depth = 6;
	test_rng_1_1->rng_bit_index = 1;

	tree_node* test_rng_1_2 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_2->rng_depth = 6;
	test_rng_1_2->rng_bit_index = 2;

	tree_node* test_rng_1_3 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_3->rng_depth = 6;
	test_rng_1_3->rng_bit_index = 3;

	tree_node* test_rng_1_4 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_4->rng_depth = 6;
	test_rng_1_4->rng_bit_index = 4;

	tree_node* test_rng_1_5 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_5->rng_depth = 6;
	test_rng_1_5->rng_bit_index = 5;

	tree_node* test_rng_1_6 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_6->rng_depth = 6;
	test_rng_1_6->rng_bit_index = 6;

	tree_node* test_rng_1_7 = tm.new_node(_RNG_RES, init_bits);
	test_rng_1_7->rng_depth = 6;
	test_rng_1_7->rng_bit_index = 7;

	tree_node* test_rng = tm.new_node(_AND, test_rng_1_0, test_rng_1_1);
	test_rng = tm.new_node(_AND, test_rng, tm.new_node(_NOT, test_rng_1_2));
	test_rng = tm.new_node(_AND, test_rng, test_rng_1_3);
	test_rng = tm.new_node(_AND, test_rng, test_rng_1_4);
	test_rng = tm.new_node(_AND, test_rng, test_rng_1_5);
	test_rng = tm.new_node(_AND, test_rng, test_rng_1_6);
	test_rng = tm.new_node(_AND, test_rng, test_rng_1_7);

	test_rng->get_cnf();

	return;
}